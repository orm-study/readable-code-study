
### 1. 객체는 `추상화된 [데이터 + 코드]`이다.

저자는 객체를 어떤 목적을 가지고 추상화된 데이터와 코드의 집합이라고 표현했다. 그냥 척 보기엔 그럴싸해서 납득이 가는 얘기인데 막상 곰곰히 생각해보면
이 또한 추상적인 거 같다. 데이터와 코드의 집합이 당최 무슨 소리인가 싶다. 객체는 메모리 위에 올라가니까 그 안에 필드들을 데이터로 본다는 건가? 코드는 그럼 무슨 소리지?
그냥 메소드 영역을 말하는건가? 그건 또 데이터가 아닌가? 

그냥 어림 짐작하기에 상태와 행위를 갖는다는 걸 의미하는 거 같긴 한데 직관적인 설명은 아닌 거 같아서 넘어가기로 했다.



### 2. 객체지향은 객체 끼리의 협력을 통해 구현되며 그로 인해 각자의 책임이 생긴다.

객체지향은 객체 끼리의 협력을 통해 구현된다 라고 했는데 그럼 협력이 없으면 객체지향이 아닌가? 사실 객체지향을 공부할 때 마다 혼란스러운 부분중에 하나다.
무조건 협력 관계가 많으면 객체지향 다운건가? 오히려 복잡해진 협력 관계 때문에 유지보수가 더 어려워지는 건 아닐까? 라는 생각도 들었다. 또한 각자의 책임이 생긴다고 하는데
책임이 왜 필요한지에 대한 설명이 먼저 선행되어야 하는게 아닐까 생각했다. 절차지향에서 그럴싸한 함수 이름으로 행위에 라벨링을 해서 사용하는것과 객체지향에서 메서드란 이름으로
행위에 라벨링을 해서 사용하는것엔 어떤 차이가 있을까? 다루는 데이터가 객체 안에서 캡슐화 되었으니 해당 데이터를 수정하는 부분을 통제할 수 있어서 더 좋은걸까? 만약에 해당 데이터를
수정하는 라인이 2줄 밖에 안된다면? 그걸 위해서 클래스를 분리하는 게 유지보수를 위해 좋은건가? 



### 3. 이러한 각각의 객체들은 관심사에 따라서 만들어낼 수 있다.

저자는 관심사 비슷한 녀석끼리 모으면 응집도, 그냥 막 모으면 결합도라는 설명을 했는데 응집도는 긍정적인, 결합도는 부정적이다는 느낌을 받았다. 




### 4. Getter나 Setter의 사용을 자제하라
아까는 객체 사이의 협력이 필요하다고 했는데 Getter조차 자제하는게 좋다고 설명했다. Getter가 없으면 개체 사이의 협력은 어떻게 할 수 있을까?
완전한 캡슐화는 어떤 이점이 있는지 잘 모르겠다.



### 6. 불필요한 필드는 줄여라
여기는 설명이 직관적이었다. 예컨대 상품 총액 필드가 있고 상품 리스트 필드가 있을 때 성능상 문제 없으면 총합 필드 두지 말고 그냥 상품 가격 계산해서 내려줘라. 라는 의미다.



### 7. 여전히 납득 가지 않는 SOLID

SOLID 관련된 내용을 보면서 든 느낌은, `이게 지금 유지 보수성에 도움이 되는 거 맞나?`라는 점이었다. 사실 DIP나 OCP 등의 내용을 보다보면 이건 사실 유지 보수성이라기 보단 `변경 용이성`을 위한 절차들이고
오히려 이런 부분을 지키기 위해 컴파일 시점과 런타임 시점의 의존관계가 변경되는 문제등으로 인해 유지보수성이 더 떨어질 가능성도 있지 않나 싶었다. 
