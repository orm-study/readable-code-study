# 3. 논리, 사고의 흐름

프로그램 = 데이터 + 코드

데이터라는 식재료를 가지고 우리가 코드로서 어떻게 요리를 해야될지

논리 구조, 사고의 흐름을 어떻게 가져가면 좋을지

> 정리 시스템에서 중요한 과제는 **최소의 인지적 노력으로 최대의 정보를 제공**하는 것이다
> 

### 인지적 경제성

최소한의 인지만을 이용해서 최대의 효율을 내보자.

# 뇌 메모리 적게 쓰기

후손들이 우리가 지금 작성한 코드를 읽을 때, 읽는 사람의 뇌 메모리를 효과적으로 쓸 수 있도록 가독성을 높이는 것이 핵심이다.

뇌 메모리에 담아야 할 정보가 많을 수록 읽기 힘든 코드가 된다.

# Early return

```java
if(a > 3){
...
} else if (a <= 3 && b > 1){
...
} else { //해당 블럭의 실행 조건을 확인하기 위해서는 앞의 두 조건을 기억하고 있어야 한다.
...
}
```

뒤의 조건을 확인하기 위해서는 앞의 조건도 모두 알고있어야 한다. → 뇌 메모리 사용량 증가

```java
void extracted(){//메서드로 추출: return을 위해서
	if(a > 3){
	...
		return;
	} 
	if (a <= 3 && b > 1){//앞의 코드를 신경 쓸 필요가 없다.
	...
		return;
	} 
	...
}
```

### Early return으로 else의 사용을 지양

메서드가 표현하고자 하는 게 명확하고 길이가 짧을 경우, else를 사용할 수도 있다.

else를 안써도 된다면, 쓰지말자.

switch case문도 비슷하다. 

뇌가 기억해야 할 정보가 많은 상태라면 그렇지 않은 방향으로 리팩토링 해보자.

# 사고의 depth 줄이기

- 중첩 분기문, 중첩 반복문
- 사용할 변수는 가깝게 선언하기

## 중첩 분기문, 중첩 반복문

```java
for (int i = 0; i < 20; i++){
	for (int j = 20; j < 30; j++){
		if(i >= 10 && j < 25){
			doSomething();
		}
	}
}
```

depth = 3

```java
for (int i = 0; i < 20; i++){
	doSomethingWithI(i);
}

private void doSomethingWithI(int i){
	for (int j = 20; j < 30; j++){
		doSomethingWithIJ(i,j);
	}
}

private void doSomethingWithIJ(int i, int j){
	if(i >= 10 && j < 25){
			doSomething();
		}
}
```

파라미터로 들어오는 i만 신경쓰면 되고, 그 바깥 로직은 일단 신경쓸 필요가 없다. 이 로직을 이해할 때 만큼은 j만 신경쓰면 된다.

→ 사고를 쪼개서 생각할 수 있게 만든다.

## 주의할 점

- ‘무조건 1 depth로 만들어라’가 아니다!
    - 보이는 depth를 줄이는 데에 급급한 것이 아니라, 추상화를 통한 **사고 과정의 depth**를 줄이는 것이 중요 (추상화되는 의미가 있는가?)
        - 보이는 depth를 줄이는 것이 아니라 사고의 depth를 줄이는 것이 핵심
    - 2중 중첩 구조로 표현하는 것이 사고하는 데에 더 도움이 된다고 판단한다면, 메서드 분리보다 그대로 놔두는 것이 더 나은 선택일 수 있다. 때로는 메서드를 분리하는 것이 더 혼선을 줄 수도 있다.

사고 과정을 생각했을 때, 무엇이 더 사고하기 좋은 코드일지 고민해보기

## 사용할 변수는 가깝게 선언하기

```java
int i = 10;
// 코드 20줄

int j = i + 30;
```

i를 사용한 코드를 봤을 때쯤 i에 대한 기억이 흐릿해짐…

```java
// 코드 20줄

int i = 10;
int j = i + 30;
```

항상 사용할 변수는 사용하는 쪽에 가깝게 두는 것이 좋다.
