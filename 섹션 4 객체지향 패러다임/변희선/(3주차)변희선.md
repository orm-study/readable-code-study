# SRP : Single Responsibility Principle(단일 책임 원칙)

- 하나의 클래스는  단한가지의 변경 이유만을 가져야 한다
    
    → 변경이유 = 책임
    
- 객체가 가진 공개 메서드,필드,상수 등은 해당 객체의 단일 책임에 의해서 변경 되는가?
- 관심사의 분리
- 높은 응집도,낮은 결합도

‘책임’을 볼 줄 아는 눈 : 경험을 해봐야 알 수 있음(인지하고 개발해보자)

1. 게임 내에 있는 책임을 분리하는것
    1. main 에서는 게임 실행만 하고 게임로직을 분리하자
    
    → 그럼 게임만 실행하니까 그에 맞춰서 기존 함수이름도 변경하면 됨
    
    b. 입/출력 분리
    
    사용자에게 보여지는 부분의 책임을 분리
    
    Exception 발생하면 어떤게 파라미터를 전달하는게 좋은가? 
     e를 출력? 아니면 아니면 메세지를 가진상태? 
    
    근데 언제든지 뽑아서 사용가능하니까 그냥 e만 출력하는방향으로 진행
    
    c.  board 분리
    
    RowSize, ColSize  만을 받아서 자동생성되게끔 변경
    

---

# OCP : Open-Closed Principle (개방-폐쇠 원칙)

- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다
    
    → 기존 코드의 변경 없이, 시스템의 기능을 확장할 수 있어야 한다.
    
- 추상와 다형성을 활용해서 OCP를 지킬 수 있다.
    
    
    > 현재 진행중인 지뢰 찾기 요구사항
    
    게임의 난이도를 변경할 수 있게 변경
    > 

1. 기존에 상수로 되어있는 배열을 변경해야함
    1. 그냥 기존 코드에 있는 상수값을 변경해보자
    2. 상수값을 변경하니까 보드가 정상적으로 출력되지 않는걸 확인하였다. 
    3. 일단은 난이도 순에 맞게 출력될수있게 변경한 후 난이도에 맞게 재설정 하는 방향으로 코드수정
2. cell을 받아오는 부분이 잘못되어 대응값이 안나오고 있어 switch문 대신 아스키코드 사용해서 수정 진행
3. 게임난이도에 맞게 변하는 보드 생성

---

# LSP : Liskov Substitution Principle(리스코프 치환 원칙)

- 상속 구조에서, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환할 수 있어야 한다.
    
    → 자식 클래스는 부모 클래스의 책임을 준수하며, 부모클래스의 행동을 변경하지 않아야 한다.
    
- LSP를 위반하면, 상속 클래스를 사용할때 오동작,예상 밖의 예외가 발생하거나, 이를 방지하기 위해 타입체크를 해야한다.

부모클래스가기능이 많을까? 자식클래스가 기능이 많을까?

당연히 자식이 많아야함 왜냐하면 부모에서 파생되어 있기때문에 부모기능에 추가적인 기능만 추가함

Cell을 상속구조로 변경해보자

1. 추상클래스를 만들자
    1. 각 메서드도 추상메서드로 변경
2. 지뢰셀 ,숫자셀, 빈셀 파일 만들기
    1. 추상메서드도 각 셀에 맞는 기능으로 변경
3. 기존 셀에서 상속구조로 되어있는 셀파일로 변경해보기
    1. 기존에는 셀을 만들어 놓고 변경하는 형식이였다면 지금은 빈셀 에서 상황에 맞게 변경하게끔 변경

---

# ISP :  Interface Segregation Principle (인터페이스 분리 원칙)

- 클라이언트는 자식이 사용하지 않는 인터페이스에 의존하면 안된다
    
    → 인터페이스를 잘게 쪼개라
    
- ISP를 위반하면, 불필요한 의존성으로 인해 결합도가 높아지고, 특정 기능의 변경이 여러 클래스에 영향을 미칠 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/638f156c-ab35-4f7a-9b1f-c5ded03b6195/0065f561-31f1-4226-87e7-983cd682115a/image.png)

인터페이스를 기능단위로 쪼개서 진행하자
