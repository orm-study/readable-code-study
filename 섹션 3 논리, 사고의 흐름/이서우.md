## 뇌 메모리 적게 쓰기

뇌라는 메모리에 적은 정보만 올릴 수 있도록 코드를 작성하면 읽기 좋은 코드가 된다.

- 이해하기 위해 기억해야 하는 정보
- 낮은 추상화 레벨
- 불필요한 정보

위와 같은 정보를 뇌에 올려놓고 코드를 읽어나가야 한다면 이해하기 위해 계속 기억하고 있어야 하는 정보가 많아져서 수행 능력이 떨어질 수 있다.

## Early Return

다음 코드까지 읽고 판단할 필요가 없다면 일찍 리턴할 수 있도록 조건문 안에서 return 키워드를 사용한다.

이렇게 하면 return이 사용되는 블록과 그 외부를 연결 지어서 생각하지 않아도 된다.

즉, 뇌 메모리를 적게 사용할 수 있다.

## 사고의 Depth 줄이기

- 중첩 분기문, 중첩 반복문 함수화 고려
  - 무조건 1 Depth로 만드는 것은 옳지 않다. 눈에 보이는 Depth를 줄여야 되는 것이 아니라, 사고 과정의 Depth를 줄여야 하는 것이다.
  - 추상화할 수 있는 의미를 가졌다면 함수화한다. 중첩된 그 자체로도 이해하는 데 어려움이 없다면 그대로 두는 것이 나은 선택일 수 있다.
- 사용할 변수는 가깝게 선언하기

## 부정 연산자를 꼭 사용해야 되는지 생각해 보기

부정 연산자(!)는 가독성이 좋지 않다.

뒤에 있는 메서드를 인지한 다음에 반대로 생각해야 돼서 사고 과정이 두 번 일어난다.

- 부정어구를 쓰지 않아도 되는 상황인지 체크
- 부정의 의미를 갖는 단어 사용 or 부정어구로 메서드명 구성

## 해피 케이스와 예외 처리

### 해피 케이스

프로그램의 진행 방향이 개발자가 원하는 베스트 시나리오대로 흘러가는 것 

의도한 대로 사용자가 입력하는 등

### 예외 처리

예외 처리를 꼼꼼하게 할수록 견고한 소프트웨어가 된다.

사용자 입력은 믿을 수 없는 데이터다. 불신을 가져야 한다.

- 값 검증이 필요한 부분은 주로 외부 세계와의 접점
    - 사용자 입력, 객체 생성자, 외부 서버의 요청등
- 의도한 예외와 예상하지 못한 예외 구분
    - 사용자에게 보여줄 예외와, 개발자가 보고 처리해야 할 예외 구분

```java
try {

} catch(/*커스텀 예외 등 사용*/) {
  // 예상한 예외
  e.printStackTrace(); // 실무에서는 안티 패턴, 예외 상황은 로그 시스템에 로그를 기록
} catch(Exception e) {
  // 예상치 못한 모든 예외
}
```

### NullPointException

- 모든 객체는 Null을 가질 수 있기 때문에 주의 필요
- 함수가 Null을 반환해야 한다면 Optional 사용을 고민
