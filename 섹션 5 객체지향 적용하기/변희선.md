# 객체 지향 적용하기

상속과 조합

상속 : 부모와 자식간의 어떤 부모의 기능을 자식이 어떤것을 추가기능 구현가능

조합 : 어떤 객체 간의 협력 하나의 객체가 자신이 필요한 한 부분에 필드에 선언해서 사용 하는 형태 컴포지션

- 상속보다 조합을 사용하자
- 상속은 시멘트처럼 굳어지는 구조로 수정이 어렵다
    
    → 부모와 자식의 결합이 낮다
    
- 조합과 인터페이스를 활용하는 것이 유연한 구조
    
    → 상속을 통한 코드의 중복 제거가 주는 이점보다, 중복이 생기더라도 유연한 구조 설계가 주는 이점이 더 큼.
    

코드의 중복제거가 미덕,효과적이라고 생각하지만 요즘은 하드웨어 발전으로 현재의 상황에서는 개발자가 더 편한 구조로 조합이 더 좋지 않을까라고 생각한다. 

확실한 상속구조가 아니라면? 웬만하면 조합구조로 변경가능하다.

**Value Object**

휼룡한 추상화 기법중 하나 기본타입을 한번 객체로 감싸서 의미를 부여하고 추상화 하는것

- 도메인의 어떤 개념을 추상화하여 표현한 값 객체
- 값으로 취급하기 위해서, 불변성,동등성,유효성 검증 등을 보장해야함
    
    → 불변성 : final 필드, setter 금지
    
    → 동등성 : 서로다른 인스턴스여도(동일성이 달라도), 내부의 값이 같으면 같은 값 객체로 취급한다. equals() & hashCode() 쟂의 필요
    
    → 유효성 검정증 : 객체가 생성되는 시점의  값에 대한 유효성을 보장하기
    
    VO(**Value Object**)vs Entity
    
    두개는 자주 비교가 된다.
    
    - Entity는 식별자가 존재한다. 식별자가 아닌 필드의 값이 달라도, 식별자가 같으면 동등한 객체로 취급한다.
        
        → equals()& hashCode()도 식별자 필드만 가지고 재정의할 수 있다.
        
        → 식별자가 같은데 식별자가 아닌 필드의 값이 서로 다른 두 인스턴드가 있다면, 같은 Entity가 시간이 지남에 따라 변화한 것으로 이해할 수도 있다.
        
    - VO는 식별자 없이, 내부의 모든 값이 다 갘아야 동등한 객체로 취급한다
        
        → 개념적으로, 전체 필드가 다같이 식별자 역할을 한다고 생각
        
   
