## 프로그래밍 패러다임

프로그래밍 패러다임은 소프트웨어 개발, 문제를 해결하기 위한 스타일, 접근 방식이다.

1. **절차 지향**
    - 순차적인 절차나 명령어로 프로그램을 구성한다.
    - 코드가 명령의 흐름을 따라 실행된다.
    - C
2. **객체 지향**
    - 객체를 중심으로 프로그램을 구성한다.
    - 객체는 속성과 행동으로 이루어져 있다.
    - 객체들 간의 상호작용을 통해 프로그램이 실행된다.
    - Java, C++, Python
3. **함수형**
    - 함수의 조합을 기반으로 프로그램을 구성한다.
    - 입력에 대한 결과는 항상 같으며, 가변 데이터를 멀리 하고 불변성을 강조한다.

## 객체가 제공하는 것

- 절차 지향에서 잘 보이지 않았던 개념을 가시화(객체 그룹을 통해)
- 관심사를 모음으로써 유지보수성 향상
    - 객체 내부에서 객체가 가지는 데이터의 유효성 검증 책임 부여 가능
- 구체적인 구현에 신경쓰지 않고 보다 높은 추상화 레벨에서 도메인 로직 작성 가능

## 객체 지향의 특징 - 캡상추다

추상화를 기반으로 하는 개념들이다.

특징을 잘 활용하면 코드의 재사용성, 유지보수성, 확장성을 높일 수 있다.

- **캡슐화(Encapsulation)**
    - 객체가 가지는 데이터와 데이터를 가공하는 로직을 숨기고, 외부에서는 공개된 인터페이스를 통해서만 상호작용할 수 있도록 하는 것이다.
    - 데이터를 보호하여 무결성을 보장하고, 유지보수를 용이하게 한다.
    - **캡슐화 예시**
        - 클래스 내의 변수는 `private`로 선언하고, 이를 조작하는 메서드는 `public`으로 제공하여 외부에서 직접적으로 데이터를 수정하지 못하게 한다.
- **상속(Inheritance)**
    - 상위 클래스의 속성과 메서드를 물려받고, 기능을 확장하거나 재정의하는 것이다.
    - 클래스 간의 관계를 표현할 수 있고, 중복 코드를 줄일 수 있다.
    - 무분별하게 사용하지 않고 정말 필요한 곳에만 사용하도록 한다.
    - **상속 예시**
        - Animal 클래스를 상속 받은 Cat, Dog 클래스는 Animal의 자원을 사용할 수 있고, 각자의 기능을 추가할 수 있다.
- **추상화(Abstraction)**
    - 본질적인 개념만 정의하고, 세부 구현은 숨긴다. 중요한 속성이나 기능만 노출한다.
    - 인터페이스나 추상 클래스를 통해 무엇을 해야 하는지를 정의한다. 사용자는 구체적인 구현을 몰라도 해당 기능을 사용할 수 있다.
    - 복잡성을 줄이고 중요한 부분만 집중할 수 있게 한다.
    - **추상화 예시**
        - Vehicle이라는 추상 클래스는 drive()라는 추상 메서드를 가지고 있고, 구체적인 Car나 Bike 클래스에서 이를 구체적으로 구현한다.
        - `Shape`라는 추상 클래스가 `draw()`라는 메서드를 정의하면, 이 메서드를 사용하는 사람은 내부적으로 도형이 어떻게 그려지는지 몰라도 `draw()`를 호출하여 도형을 그리게 할 수 있다. 구체적인 도형이 어떤 방식으로 그려지는지는 각 도형 클래스에 맡겨진다.
- **다형성(Polymorphism)**
    - 하나의 메서드나 객체가 여러 형태를 가질 수 있는 것을 의미한다.
    - [메서드] 오버로딩은 동일한 이름의 메서드를 여러 개 정의하는 것이다. 이름은 같지만, 매개변수의 개수나 타입은 다르다.
    - [메서드] 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 자신에 맞게 재정의하여 사용하는 것이다.
    - [객체] 특징을 추출해서 인터페이스화 하고, 실제 구현체가 여러가지 형태로 바뀌며 사용될 수 있도록 하는 것이다.
    - 하나의 인터페이스나 부모 클래스를 통해 여러 다른 구체적인 객체들을 동일한 방식으로 다룰 수 있게 한다.
    - **다형성 예시**
        - `draw()` 메서드가 `Circle`, `Rectangle` 등 다양한 도형 객체에서 각기 다른 방식으로 동작할 수 있다.
        - `Shape`의 서브클래스인 `Circle`, `Rectangle`, `Triangle`이 각각 다르게 `draw()` 메서드를 구현하면, `Shape` 타입으로 `draw()`를 호출할 때 실제 객체에 따라 다른 도형을 그리게 된다.

### 추상화와 다형성

추상화와 다형성의 개념은 혼동될 수 있다. 두 개념은 밀접하게 관련이 있지만, 차이점이 있다.

**특징을 추출해서 인터페이스화 하고, 실제 구현체가 여러 가지 형태로 바뀌며 사용될 수 있다**는 설명은 **두 개념이 결합**된 경우다.

**추상화**는 객체들이 제공할 기능을 정의하는 것이고, **다형성**은 실제 객체가 해당 기능을 어떻게 다르게 구현하고 동작할 수 있는지를 말하는 것이다.

특징을 추출해서 인터페이스화를 하는 것은 **추상화**를 하는 것이고, 실제 구현체가 여러 가지 형태로 바뀌며 사용되도록 하는 것은 **다형성**을 의미하는 것이다.

이 두 개념은 서로 보완적인 역할을 하며, 함께 사용될 때 코드의 **재사용성**과 **유연성**을 높여준다.

**추상화**는 **공통된 기능**을 정의하고, 다양한 객체들이 그 기능을 활용할 수 있도록 한다. 이를 통해 **코드의 재사용성**이 증가합니다.

**다형성**은 **하나의 인터페이스나 부모 클래스를 통해 여러 가지 형태의 객체**를 동일한 방식으로 처리할 수 있게 해준다. 새로운 객체를 쉽게 확장할 수 있고, 다양한 객체를 일관되게 다룰 수 있어 **확장성**과 **유연성**이 향상된다.

다시 정리하자면 다음과 같다.

- **추상화**는 공통된 특징을 뽑아내어 인터페이스나 추상 클래스로 정의하는 것
- **다형성**은 그 인터페이스를 구현하는 다양한 객체들이 **각기 다른 방식**으로 동작할 수 있게 하는 것

## 관심사의 분리

관심사에 따라서 객체를 만들어낼 수 있다. 관심사에 따라 기능과 책임을 나누고, 나눈 것들의 조합으로 프로그램이 수행되도록 하는 것이다. (객체 지향에서만 적용되는 개념은 아니다.)

관심사를 분리한다는 것은 일련의 작업, 개념들을 묶어서 이름, 역할을 부여하는 것이다. 이 또한 추상화 과정의 일면인 것이다.

관심사를 분리하여 객체의 책임을 나누게 되면서 객체 간 협력이 필요해질 수 있다.

### 높은 응집도, 낮은 결합도

관심사를 모으는 것은 응집도를 높이는 것이다.

각 관심사끼리는 결합도가 낮아야 한다. 결합도는 하나가 바뀔 때 다른 것이 영향을 받는 정도를 의미한다.

### 관심사를 모으는 것의 장점

유지보수가 원활해진다.

A라는 관심사를 가진 객체, 모듈, 시스템 등을 모아서 관리하면 A에 대한 것은 해당 항목에 가서 유지보수를 하면 되기 때문이다.

만약 A에 대한 것이 프로그램의 이곳저곳에 관리되지 않은 채로 퍼져있다면 모든 부분을 찾아서 관리해야 한다.
