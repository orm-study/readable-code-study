# Object 02_객체지향 프로그래밍

### 협력, 객체, 클래스

- `대부분의 사람들은 클래스르 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민한다.`
    - 안타깝게 이것은 객체지향의 본질과 멀다.
- `진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때 얻을 수 있다.`
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해라.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
    1. 객체는 홀로 존재하는 것이 아니다.

### 도메인

- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라 칭한다
- 문제를 해결하는 영역이라고 볼 수 있다.

### 클래스 구현하기

- 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
- 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 만들어야 한다.
- 그렇다면 클래스의 내부와 외부를 구분하는 이유는 무엇일까?
    - 경계의 명확성이 객체의 자율성을 보장하기 때문이다.

### 자율적인 객체

- 데이터와 기능을 객체 내부로 함께 묶는 것을 **캡슐화라고 부른다.**
- 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다.
- 캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
    1. 외부에서 접근 가능한 부분으로 이를 퍼블릭 인터페이스(public interface)라고 부른다.
    2. 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 구현(implementation)이라고 부른다.
        1. 인테페이스와 구현의 분리(separation of interface and implementation) 원칙은 휼륭한 객체지향 프로그램을 만들기 이해 따라야 하는 핵심 원칙이다.

### 프로그래머의 자유

- 프로그래머의 역할을 `클래스 작성자`와 `클라이언트 프로그래머` 로 구분하는 것이 유용하다.
    - 클래스 작성자 : 새로운 데이터 타입을 프로그램에 추가한다.
    - 클라이언트 프로그래머 : 클래스 작성자가 추가한 데이터 타입을 사용한다.
- 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다.
- 클라이언트 프로그래머는 숨겨 놓은 부분을 접근할 수 없으며, 클라이언트 프로그래머에 대한 영향을 걱정하지 않고 클래스 작성자는 내부 구현을 마음대로 변경할 수 있다.
    - 이를 구현 은닉이라 부른다.
- 객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.
- 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

### Q. 추상 클래스는 인스턴스 생성이 불가능한가?

A. 상속받은 구체 클래스를 통해서만 인스턴스 생성이 가능핟. 

### Template Method 디자인 패턴 (책 52 페이지)

- DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만, 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에게 위임한다.
실제로 DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메서드가 실행될 것이다. 
이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 패턴이 템플릿 메서드라고 부른다.

### 오버라이딩 vs 오버로딩

오버라이딩 : 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우를 가리킨다.

오버로딩 : 클래스 내부 두 개 이상 메서드의 이름은 같지만 제공되는 파라미터의 목록(타입)이 다르다. 

### 컴파일 시간 의존성과 실행 시간 의존성

- 코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다는 것이다.
- 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다.
    - 반면, 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더욱 유연해지고 확장 가능해진다.
- 설계가 유연해 질수록 코드를 이해하고 디버깅하기는 점점더 어려워 진다는 사실을 기억하라 (trade-off)
    - 반면, 유연성을 억제하면 코드를 이해하고 디버깅하기 쉽지만, 재사용성과 확정 가능성은 낮아진다.

### 상속과 인터페이스

- Movie는 협력 객체가 calculateDiscountAmount라는 메시지를 이해할 수만 있다면 그 객체가 어떤 클래스의 인스턴스인지 상관하지 않다는 것이다. (책 61 페이지)
- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부른다.
    - 반대로, 부모 클래스 자식 클래스를 대신하는 것을 다운캐스팅(downcasting)이라 부른다.

### 다형성

- 메시지와 메서드는 다른 개념이다.
- Movie는 DiscountPolicy의 인스턴스에게 calculateDiscountAmount 메시지를 전송한다.
    - 그렇다면 실행되는 메서드는 무엇인가? → 연결된 객체의 클래스가 무엇인가에 따라 달라진다.
- 다시 말해서 Movie는 동일한 메시지를 전송하지만, 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. → 이를 바로 다형성이라고 부른다.
- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 다형성이란 ? → 동일한 메시지를 수신했을때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
- 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정 → 지연 바인딩 or 동적 바인딩 이라고 부른다.
    - 그에 반대로, 전통적인 함수 호출처럼 컴파일 시점에 결정 → 초기 바인딩 or 정적 바인딩 이라고 부른다.

### 상속 (상속을 구현 상속과 인터페이스 상속으로 분류할 수 있다)

- 구현 상속 : 순수하게 코드를 재사용하기 위한 목적으로 상속하는 것을 구현 상속이라고 부른다.
- 인터페이스 상속 : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것이 인터페이스 상속이라고 부른다.
- 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. 대부분의 사람들은 코드 재사용을 위해 상속의 주도니 목적이라고 생각하지만 이것은 오해다.
구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다. 또한 결합도 또한 높아질 수 있다.

### 추상의 힘

- 추상화를 사용할 경우 두 가지 장점을 보여준다.
    1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
    2. 설계가 좀 더 유연해진다.

### 유연한 설계

- 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해라
- DiscountPolicy는 수정하지 않고 NoneDiscountPolicy라는 새로은 클래스를 추가하는 것만으로 애플리케이션 기능을 확장했다는 것이다. (책 67 페이지)
- 추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있다.
    - 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문이다.
- 유연성이 필요한 곳에 추상화를 사용하라.

### 코드 재사용

- 합성이 더 좋다는 이야기를 들었을 것이다.
- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.

### 상속

- 상속은 객체지향에서 코드를 재사용하기 위한 기법
- 하지만 상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
    1. 캡술화를 위반한다.
    2. 설계를 유연하지 못하게 만든다.
- 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약해진다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 
부모 클래스를 변경할 때 자식클래스도 함께 변경될 확률이 높다.
- 상속은 부모 클래스와 자식 클래스 사이 관계를 컴파일 하는 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

### 합성

- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 한다.
- 합성은 상속이 가지는 두 가지의 문제를 해결한다.
1. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
2. 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
3. 객체지양헤서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다. 
객체들은 협력에 참여하기 위해 역할을 부여받고 역할에 적절한 책임을 수행한다.