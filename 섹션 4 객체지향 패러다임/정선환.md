**"ì½”ë“œëŠ” ì‘ì„±í•˜ê³  ë‚œ ìˆœê°„ë¶€í„° ë ˆê±°ì‹œë‹¤"**

ìš°ë¦¬ëŠ” ìƒˆë¡œìš´ ì½”ë“œì˜ ì“°ê¸°ë³´ë‹¤ ì½ê¸°ì˜ ì‹œê°„ ë¹„ìœ¨ì´ ì••ë„ì ìœ¼ë¡œ ë†’ë‹¤. ë” ë‚˜ì€ ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ë§Œë“¤ê³  ë” ë‚˜ì€ í˜‘ì—…ì„ í•˜ê¸° ìœ„í•´ì„œ ì½”ë“œë¥¼ ì‘ì„±í•  ë•ŒëŠ” ë‚˜ë§Œì„ ìœ„í•œ ì“°ê¸° ì½”ë“œê°€ ì•„ë‹Œ ì½ê¸°ë¥¼ ê¸°ë°˜í•˜ì—¬ ì‘ì„± í•˜ëŠ” ê²ƒë„ ì¤‘ìš”í•˜ë‹¤. 

ë¯¸ë˜ì˜ ë‚˜, ë¯¸ë˜ì˜ ë‚˜ì˜ ë™ë£Œë“¤ì„ ìœ„í•´ ê³µë¶€í•˜ê³  ê¸°ë¡í•œë‹¤.

---

## 1. ì¶”ìƒì˜ ê´€ì ìœ¼ë¡œ ë°”ë¼ë³´ëŠ” ê°ì²´ ì§€í–¥
ì—¬ëŸ¬ í”„ë¡œê·¸ë˜ë° ê°œë…ë“¤ì€ ì½”ë“œì˜ êµ¬ì¡°ì™€ ì„¤ê³„ë¥¼ ì´í•´í•˜ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•œë‹¤. ê°ê°ì˜ ê°œë…ì€ í”„ë¡œê·¸ë˜ë° ë°©ì‹ì´ë‚˜ íŒ¨ëŸ¬ë‹¤ì„ì„ ì„¤ëª…í•˜ëŠ” ë° ì“°ì´ë©°, ì´ë¥¼ ì˜ ì´í•´í•˜ë©´ ë” ë‚˜ì€ ì„¤ê³„ì™€ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 1.1. **ì ˆì°¨ (Procedural Programming)**
ì ˆì°¨ëŠ” í”„ë¡œê·¸ë¨ì´ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ë°©ì‹ì„ ë§í•œë‹¤. ì ˆì°¨ì  í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë©°, ì½”ë“œê°€ ìœ„ì—ì„œ ì•„ë˜ë¡œ ìˆœì°¨ì ìœ¼ë¡œ íë¦…ë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì€ ë°ì´í„°ë¥¼ ì¡°ì‘í•˜ê³ , ê·¸ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‘ì—…ì„ ì²˜ë¦¬í•˜ëŠ” **ëª…ë ¹**ì˜ ëª¨ìŒì…ë‹ˆë‹¤.

* ì½”ë“œê°€ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë¨.
* ë°ì´í„°ì™€ í•¨ìˆ˜ë¥¼ ë¶„ë¦¬í•´ì„œ ì‘ì„±í•¨.
* ì „ì—­ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜, ìƒíƒœë¥¼ ê³µìœ í•˜ëŠ” ë°©ì‹ì´ ì¼ë°˜ì ì„.
  
### 1.2. **ê°ì²´ ì§€í–¥ (Object-Oriented Programming, OOP)**

ê°ì²´ ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì€ ë°ì´í„°ì™€ ê·¸ ë°ì´í„°ë¥¼ ì¡°ì‘í•˜ëŠ” **ë©”ì†Œë“œ(í•¨ìˆ˜)**ë¥¼ í•˜ë‚˜ì˜ ë‹¨ìœ„, ì¦‰ **ê°ì²´**ë¡œ ë¬¶ëŠ” ë°©ì‹ì´ë‹¤. OOPì—ì„œëŠ” ê°ì²´ê°€ í”„ë¡œê·¸ë¨ì˜ ê¸°ë³¸ êµ¬ì„± ë‹¨ìœ„ê°€ ë˜ë©°, ì´ ê°ì²´ë“¤ì€ ì„œë¡œ **ìƒí˜¸ì‘ìš©**í•˜ë©´ì„œ í”„ë¡œê·¸ë¨ì„ êµ¬ì„±í•œë‹¤.

> ğŸ‘‰ ** ê°ì²´ì§€í–¥ íŠ¹ì§• (ìº¡ìƒì¶”ë‹¤) **
* **ìº¡ìŠí™”**: ê°ì²´ëŠ” ë°ì´í„°ì™€ ë©”ì†Œë“œë¥¼ í•¨ê»˜ ë¬¶ê³ , ì™¸ë¶€ì—ì„œëŠ” ê°ì²´ì˜ ë‚´ë¶€ ìƒíƒœì— ì§ì ‘ ì ‘ê·¼í•˜ì§€ ëª»í•˜ê²Œ í•¨.
* **ìƒì†**: í´ë˜ìŠ¤ëŠ” ë‹¤ë¥¸ í´ë˜ìŠ¤ë¡œë¶€í„° ì†ì„±ê³¼ ë©”ì†Œë“œë¥¼ ë¬¼ë ¤ë°›ì„ ìˆ˜ ìˆìŒ.
* **ì¶”ìƒí™”**: ë¶ˆí•„ìš”í•œ ì„¸ë¶€ ì‚¬í•­ì„ ê°ì¶”ê³  ì¤‘ìš”í•œ ë¶€ë¶„ë§Œ í‘œí˜„í•¨.
* **ë‹¤í˜•ì„±**: ë™ì¼í•œ ë©”ì†Œë“œê°€ ë‹¤ë¥¸ ê°ì²´ì—ì„œ ë‹¤ë¥´ê²Œ ë™ì‘í•  ìˆ˜ ìˆìŒ.

  
### 1.3. **í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° (Functional Programming)**

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ í”„ë¡œê·¸ë˜ë°ì„ **ìˆœìˆ˜ í•¨ìˆ˜**ë¡œ êµ¬ì„±ëœ ìˆ˜í•™ì  ê³„ì‚°ì²˜ëŸ¼ ë‹¤ë£¨ëŠ” íŒ¨ëŸ¬ë‹¤ì„ì´ë‹¤. **ìƒíƒœ ë³€í™”**ë¥¼ í”¼í•˜ê³  **ë¶€ìˆ˜ íš¨ê³¼(Side Effect)** ê°€ ì—†ëŠ” ì½”ë“œë¥¼ ì§€í–¥í•œë‹¤. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ë³€í•˜ì§€ ì•ŠëŠ” ê°’ì„ ì‚¬ìš©í•˜ëŠ” **ë¶ˆë³€ì„±(immutability)** ì´ ì¤‘ìš”í•œ ì›ì¹™ì´ë‹¤.


## 2. ê°ì²´ ì„¤ê³„í•˜ê¸°

### 2.1. ê°ì²´ë¡œ ì¶”ìƒí™” í•˜ê¸°

* ë¹„ê³µê°œ í•„ë“œ(ë°ì´í„°), ë¹„ê³µê°œ ë¡œì§(ì½”ë“œ)
* ê³µê°œ ë©”ì„œë“œ ì„ ì–¸ë¶€ë¥¼ í†µí•´ ì™¸ë¶€ ì„¸ê³„ì™€ ì†Œí†µ (ê° ë©”ì„œë“œì˜ ê¸°ëŠ¥ì€ ê°ì²´ì˜ ì±…ì„ì„ ë“œëŸ¬ë‚´ëŠ” ì°½êµ¬)
* ê°ì²´ì˜ ì±…ì„ì´ ë‚˜ë‰¨ì— ë”°ë¼ ê°ì²´ ê°„ í˜‘ë ¥ì´ ë°œìƒ

### 2.2. ê°ì²´ê°€ ì œê³µí•˜ëŠ” ê²ƒ
* ì ˆì°¨ ì§€í–¥ì—ì„œ ì˜ ë³´ì´ì§€ ì•Šì•˜ë˜ ê°œë…ì„ ê°€ì‹œí™”
* ê´€ì‹¬ì‚¬ê°€ í•œ êµ°ë°ë¡œ ëª¨ì´ê¸° ë•Œë¬¸ì— ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ (ê°ì²´ ë‚´ë¶€ì—ì„œ ê°ì²´ê°€ ê°€ì§„ ë°ì´í„°ì˜ ìœ íš¨ì„± ê²€ì¦ ì±…ì„ì„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤)
* ì—¬ëŸ¬ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ì…ì¥ì—ì„œëŠ” êµ¬ì²´ì ì¸ êµ¬í˜„ì— ì‹ ê²½ì“°ì§€ ì•Šê³  ë³´ë‹¤ ë†’ì€ ì¶”ìƒí™” ë ˆë²¨ì—ì„œ ë„ë©”ì¸ ë¡œì§ì„ ë‹¤ë£° ìˆ˜ ìˆë‹¤.

### 2.3. ìƒˆë¡œìš´ ê°ì²´ë¥¼ ë§Œë“¤ ë•Œ ì£¼ì˜í•  ì 

* **1ê°œì˜ ê´€ì‹¬ì‚¬ë¡œ ëª…í™•í•˜ê²Œ ì±…ì„ì´ ì •ì˜ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê¸°**
	- ë©”ì„œë“œë¥¼ ì¶”ìƒí™”í•  ë•Œì™€ ë¹„ìŠ·í•˜ë‹¤.
	- ê°ì²´ë¥¼ ë§Œë“¦ìœ¼ë¡œì¨ ì™¸ë¶€ ì„¸ê³„ì™€ ì–´ë–¤ ì†Œí†µì„ í•˜ë ¤ëŠ”ì§€ ìƒê°í•œë‹¤.


* **ìƒì„±ì, ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œì—ì„œ ìœ íš¨ì„± ê²€ì¦ì´ ê°€ëŠ¥í•˜ë‹¤.**

```java
class Money {
	private long value;

	public Money(long value) {
      if (value < 0) {
          throw new IllegalArgumentException("ëˆì€ 0ì› ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
      }
    this.value = value;
	}
}
```
    
* **setter ì‚¬ìš© ìì œ**
	- ë°ì´í„°ëŠ” ë¶ˆë³€ì´ ìµœê³ ë‹¤. ë³€í•˜ëŠ” ë°ì´í„°ì´ë”ë¼ë„ ê°ì²´ê°€ í•¸ë“¤ë§í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.
	- ê°ì²´ ë‚´ë¶€ì—ì„œ ì™¸ë¶€ ì„¸ê³„ì˜ ê°œì… ì—†ì´ ìì²´ì ì¸ ë³€ê²½/ê°€ê³µìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ”ì§€ë¥¼ í™•ì¸í•œë‹¤.
	- ë§Œì•½ ì™¸ë¶€ì—ì„œ ê°€ì§€ê³  ìˆëŠ” ë°ì´í„°ë¡œ ë°ì´í„° ë³€ê²½ ìš”ì²­ì„ í•´ì•¼ í•˜ëŠ” ê²½ìš° 'set~'ì´ë¼ëŠ” ë‹¨ìˆœí•œ ì´ë¦„ë³´ë‹¤ 'update~' ì™€ ê°™ì´ ì˜ë„ë¥¼ ë“œëŸ¬ì• ëŠ” ë„¤ì´ë°ì„ ê³ ë ¤í•˜ì
    
* **getter ë„ ì‚¬ìš© ìì œ**
	- ì™¸ë¶€ì—ì„œ ê°ì²´ ë‚´ ë°ì´í„°ê°€ í•„ìš”í•˜ë‹¤ê³  getterë¥¼ ë‚¨ë°œí•˜ëŠ” ê²ƒì€ ë¬´ë¡€í•œ í–‰ë™
```java
Pserson person = new Person();

//(1)
if (person.getì§€ê°‘().getì‹ ë¶„ì¦().findAge() >= 19) {
	pass();
}

// (2)
if(person.isAgeGreaterThanOrEqualTo(19)) {
	pass();
}
```

* **í•„ë“œì˜ ìˆ˜ëŠ” ì ì„ìˆ˜ë¡ ì¢‹ë‹¤.**
	- ë¶ˆí•„ìš”í•œ ë°ì´í„°ê°€ ë§ì„ìˆ˜ë¡ ë³µì¡ë„ê°€ ë†’ì•„ì§€ê³  ëŒ€ì‘í•  ë³€í™”ê°€ ë§ì•„ì§„ë‹¤.
    
    
## 3. SOLID ì›ì¹™
Robert C.Martinì´ 2000ë…„ì— 

### 3.1. SRP: Single Responsibility Principle, ë‹¨ì¼ ì±…ì„ ì›ì¹™

* í•˜ë‚˜ì˜ í´ë˜ìŠ¤ëŠ” ë‹¨ í•œê°€ì§€ì˜ ë³€ê²½ ì´ìœ ë§Œì„ ê°€ì ¸ì•¼ í•œë‹¤. (ë³€ê²½ ì´ìœ  = ì±…ì„)
* ê°ì²´ê°€ ê°€ì§„ ê³µê°œ ë©”ì„œë“œ, í•„ë“œ, ìƒìˆ˜ ë“±ì€ í•´ë‹¹ ê°ì²´ì˜ ë‹¨ì¼ ì±…ì„ì— ì˜í•´ì„œë§Œ ë³€ê²½ ë˜ëŠ”ê°€?
* ê´€ì‹¬ì‚¬ì˜ ë¶„ë¦¬
* ë†’ì€ ì‘ì§‘ë„, ë‚®ì€ ê²°í•©ë„

```java
// ì˜ëª»ëœ SRP
class Employee {
    private String name;
    private String address;
    
    public Employee(String name, String address) {
        this.name = name;
        this.address = address;
    }

    // ì§ì› ì •ë³´ ì²˜ë¦¬ ë©”ì†Œë“œ
    public void save() {
        // ì§ì› ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ì½”ë“œ
    }

    // ì§ì› ì„¸ê¸ˆ ê³„ì‚° ì²˜ë¦¬ ë©”ì†Œë“œ
    public double calculateTax() {
        // ì„¸ê¸ˆ ê³„ì‚° ë¡œì§
        return 0.0;
    }
}
```
* ìœ„ í´ë˜ìŠ¤ëŠ” ì§ì› ì •ë³´ ì €ì¥ê³¼ ì„¸ê¸ˆ ê³„ì‚°ì´ë¼ëŠ” ë‘ ê°€ì§€ ì±…ì„ì„ ê°€ì§€ê³  ìˆë‹¤.
```java
// ì˜¬ë°”ë¥¸ SRP
class Employee {
    private String name;
    private String address;

    public Employee(String name, String address) {
        this.name = name;
        this.address = address;
    }
    
    // ì§ì› ê´€ë ¨ ë¡œì§ë§Œ ì²˜ë¦¬
}

class EmployeeRepository {
    public void save(Employee employee) {
        // ì§ì› ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ì½”ë“œ
    }
}

class TaxCalculator {
    public double calculateTax(Employee employee) {
        // ì„¸ê¸ˆ ê³„ì‚° ë¡œì§
        return 0.0;
    }
}

```

### 3.2. OCP: Open-Closed Principle, ê°œë°©-íì‡„ ì›ì¹™
* í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³ , ìˆ˜ì •ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼ í•œë‹¤. (ê¸°ì¡´ ì½”ë“œì˜ ë³€ê²½ ì—†ì´, ì‹œìŠ¤í…œì˜ ê¸°ëŠ¥ì„ í™•ì¥í• ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.)
* ì¶”ìƒí™”ì™€ ë‹¤í˜•ì„±ì„ í™œìš©í•´ì„œ OCPë¥¼ ì§€í‚¬ ìˆ˜ ìˆë‹¤.

```java
// ì˜ëª»ëœ OCP
class Shape {
    public String type;
}

class AreaCalculator {
    public double calculate(Shape shape) {
        if (shape.type.equals("circle")) {
            return Math.PI * 3 * 3; // ì›ì˜ ë„“ì´ ê³„ì‚°
        } else if (shape.type.equals("rectangle")) {
            return 4 * 5; // ì‚¬ê°í˜•ì˜ ë„“ì´ ê³„ì‚°
        }
        return 0;
    }
}
```
* ìƒˆë¡œìš´ ë„í˜•ì´ ì¶”ê°€ë  ë•Œë§ˆë‹¤ calculate ë©”ì†Œë“œë¥¼ ìˆ˜ì •í•´ì•¼ í•˜ë¯€ë¡œ OCPë¥¼ ìœ„ë°˜í•˜ê³  ìˆë‹¤.

```java
// ì˜¬ë°”ë¥¸ OCP

// í™•ì¥ì„ ìœ„í•´ ì¶”ìƒ í´ë˜ìŠ¤ë‚˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©
abstract class Shape {
    public abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return width * height;
    }
}

class AreaCalculator {
    public double calculate(Shape shape) {
        return shape.calculateArea();
    }
}

```
### 3.3. LSP: Liskov Substitution Principle, ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™
* ìƒì† êµ¬ì¡°ì—ì„œ, ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìì‹ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´íŠ¸ë¡œ ì¹˜í™˜ í•˜ë¼ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. (ìì‹ í´ë˜ìŠ¤ëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ì±…ì„ì„ ì¤€ìˆ˜í•˜ë©°, ë¶€ëª¨ í´ë˜ìŠ¤ì˜ í–‰ë™ì„ ë³€ê²½í•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤)
* LSPë¥¼ ìœ„ë°˜í•˜ë©´ ìƒì† í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•  ë•Œ ì˜¤ë™ì‘, ì˜ˆìƒ ë°–ì˜ ì˜ˆì™¸ê°€ ë°œìƒí•˜ê±°ë‚˜ ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ ë¶ˆí•„ìš”í•œ íƒ€ì… ì²´í¬ê°€ ë™ë°˜ë  ìˆ˜ ìˆë‹¤.

```java
// ì˜ëª»ëœ LSP
class Bird {
    public void fly() {
        System.out.println("Bird is flying");
    }
}

class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Ostrich can't fly");
    }
}

```
* íƒ€ì¡°(Ostrich)ëŠ” ë‚  ìˆ˜ ì—†ëŠ”ë° fly ë©”ì†Œë“œë¥¼ êµ¬í˜„í•œ ê²ƒì€ LSPë¥¼ ìœ„ë°˜í•˜ê³  ìˆë‹¤.

```java
// ì˜¬ë°”ë¥¸ LSP
abstract class Bird {
    public abstract void move();
}

class Sparrow extends Bird {
    @Override
    public void move() {
        System.out.println("Sparrow is flying");
    }
}

class Ostrich extends Bird {
    @Override
    public void move() {
        System.out.println("Ostrich is running");
    }
}

```
### 3.4. ISP: Interface Segregation Principle, ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™
* í´ë¼ì´ì–¸íŠ¸ëŠ” ìì‹ ì´ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´í•˜ë©´ ì•ˆëœë‹¤. (ì¸í„°í˜ì´ìŠ¤ë¥¼ ì˜ê²Œ ìª¼ê°œë¼!)	
* ISPë¥¼ ìœ„ë°˜í•˜ë©´ ë¶ˆí•„ìš”í•œ ì˜ì¡´ì„±ìœ¼ë¡œ ì¸í•´ ê²°í•©ë„ê°€ ë†’ì•„ì§€ê³  íŠ¹ì •ê¸°ëŠ¥ì˜ ë³€ê²½ì´ ì—¬ëŸ¬ í´ë˜ìŠ¤ì— ì˜í–¥ì„ ë¯¸ì¹  ìˆ˜ ìˆë‹¤.

```java
// ì˜ëª»ëœ ISP
interface Worker {
    void work();
    void eat();
}

class Developer implements Worker {
    public void work() {
        System.out.println("Developer is coding");
    }
    public void eat() {
        // í•„ìš” ì—†ëŠ” ë©”ì†Œë“œì§€ë§Œ êµ¬í˜„í•´ì•¼ í•¨
    }
}

class Robot implements Worker {
    public void work() {
        System.out.println("Robot is working");
    }
    public void eat() {
        throw new UnsupportedOperationException("Robot doesn't eat");
    }
}
```
* ë¡œë´‡ì€ eat() ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ, ì¸í„°í˜ì´ìŠ¤ ë•Œë¬¸ì— êµ¬í˜„í•´ì•¼ í•˜ë¯€ë¡œ ISPë¥¼ ìœ„ë°˜í•˜ê³  ìˆë‹¤.

```java
// ì˜¬ë°”ë¥¸ ISP
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Developer implements Workable, Eatable {
    public void work() {
        System.out.println("Developer is coding");
    }
    public void eat() {
        System.out.println("Developer is eating");
    }
}

class Robot implements Workable {
    public void work() {
        System.out.println("Robot is working");
    }
}

```

### 3.5. DIP: Dependency Incersion Principle, ì˜ì¡´ ì—­ì „ ì›ì¹™
* ìƒìœ„ ìˆ˜ì¤€ì˜ ëª¨ë“ˆì€ í•˜ìœ„ ìˆ˜ì¤€ì˜ ëª¨ë“ˆì— ì˜ì¡´í•´ì„œëŠ” ì•ˆëœë‹¤. (ë‘˜ ëª¨ë‘ ì¶”ìƒí™”ì— ì˜ì¡´í•´ì•¼í•œë‹¤.)
* ì˜ì¡´ì„±ì˜ ìˆœë°©í–¥ : ê³ ìˆ˜ì¤€ ëª¨ë“ˆì´ ì €ìˆ˜ì¤€ ëª¨ë“ˆì„ ì°¸ì¡°í•˜ëŠ” ê²ƒ
* ì˜ì¡´ì„±ì˜ ì—­ë°©í–¥ : ê³ ìˆ˜ì¤€, ì €ìˆ˜ì¤€ ëª¨ë“ˆì´ ëª¨ë‘ ì¶”ìƒí™”ì— ì˜ì¡´í•˜ëŠ” ê²ƒ (ì €ìˆ˜ì¤€ ëª¨ë“ˆì´ ë³€ê²½ë˜ì–´ë„, ê³ ìˆ˜ì¤€ ëª¨ë“ˆì—ëŠ” ì˜í–¥ì´ ê°€ì§€ ì•ŠëŠ”ë‹¤.)

```java
// ì˜ëª»ëœ DIP
class Keyboard {
    public String input() {
        return "User input from keyboard";
    }
}

class Computer {
    private Keyboard keyboard;

    public Computer() {
        this.keyboard = new Keyboard();
    }

    public void getInput() {
        System.out.println(keyboard.input());
    }
}
```
* `Computer`ëŠ” `Keyboard` í´ë˜ìŠ¤ì— ì§ì ‘ ì˜ì¡´í•˜ê³  ìˆìœ¼ë¯€ë¡œ DIPë¥¼ ìœ„ë°˜í•˜ê³  ìˆë‹¤.

```java
// ì˜¬ë°”ë¥¸ DIP
interface InputDevice {
    String input();
}

class Keyboard implements InputDevice {
    public String input() {
        return "User input from keyboard";
    }
}

class Computer {
    private InputDevice inputDevice;

    public Computer(InputDevice inputDevice) {
        this.inputDevice = inputDevice;
    }

    public void getInput() {
        System.out.println(inputDevice.input());
    }
}

public class DIPExample {
    public static void main(String[] args) {
        InputDevice keyboard = new Keyboard();
        Computer computer = new Computer(keyboard);
        computer.getInput();
    }
}

```


