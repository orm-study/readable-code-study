
> ## 1. 상속과 조합

.. 저자는 상속과 조합에 대해 설명하면서 `무조건 변하지 않는다거나 상속관계가 명확한 경우에만 상속을 사용하는게 좋다. 물론 변하지 않는 건 없습니다만 ..` 이라고 설명했다. 
무슨 근거에서 그런건지는 그냥 뭉뜽그려 설명했는데, 조합을 이용하면 좀 더 유연하게 수정할 수 있다는 `변경 용이성`을 그 예로 든 거 같다. 
근데 사실 나는 이 얘기를 다룰 때 `변경 용이성`과 `가독성` 사이의 트레이드 오프 같은 것들을 설명할 줄 알았는데 반전은 없었고 그냥 상속은 구린 정책이다 같은 뉘앙스로 느껴져서 좀 실망했다.

<br> 

.. 그리고 그 뒤에 조합을 사용하면 좋은 이유를 설명해주는데 아래와 같다.

- 상속을 통한 코드의 중복 제거가 주는 이점보다
- 중복이 생기더라도 유연한 구조 설계가 주는 이점이 더 크다.

위 예시를 납득시키기 위해 진행하는 과정을 코드로 보여주셨는데, 2개의 필드 수정의 영향을 없애기 위해 인터페이스도 만들고 이렇게 저렇게 하시는 거 같았는데 이런 작업이 필요할정도로 그렇게 치명적인 문제인가 싶긴 했다.
단순히 충분한 시간적 여유가 있고 조합을 적용할만한 상황임을 가정하더라도 `결합도가 커지는게 왜 그렇게 큰 문제지?` 라는 의문은 솔직히 해소되진 않았다. 결합도가 커지면 바꾸면 되는 거 아닌가? 조합으로 인해 인터페이스도 생기고
구조적으로 복잡해진다던지 코드를 봤을 때 정확히 어떤 클래스가 실제로 사용되는지 한 눈에 볼 수 없다는 컴파일 시점과 런타임 환경의 불일치로 인한 복잡성 증가의 문제 같은 것들은? 시스템의 규모나 팀의 컨벤션은? 
그런 것들이 항상 `유연한 구조가 주는 이점이 더 크니 컴포지션 써라`라는 결론의 근거로 합당할까? 잘 모르겠다.



<br>



> ## 2. 값 객체 (VO: ValueObject)

- 값 객체는 불변성(final 사용, setter 금지), 동등성(서로 다른 인스턴스여도 값이 같으면 같은 취급, equals()나 hashcode()의 재정의가 필요), 유효성 검증(객체 생성 시점에 값에 대한 유효성 검증하기)라는 3가지 성질을 갖춰야한다.

<br>

.. 그래서 값 객체는 만원권 지폐 같은건데, 만원 식별 번호가 어쨌든 우리한테는 똑같은 만원이지 않은가? 그런 느낌이 값 객체고 거기에 식별 값을 통해 만원을 구분키로 한다면 그게 엔터티다. 


> ## 3. first class 

- 일급 ~~이라는게 사실 직관적이지 않은데 걍 대충 막 여기저기 던지고 받을 수 있는 컬렉션을 의미한다.

그래서 예컨대 first class function은 아래 3가지 조건을 만족하는 함수를 의미하는데
```
// 1. 함수를 변수에 할당
const sayHello = function() {
 console.log("Hello!");
};

// 2. 함수를 다른 함수의 인자로 전달 
function greet(fn) {
 fn();
}
greet(sayHello);

// 3. 함수를 다른 함수의 반환값으로 사용
function getGreeter() {
 return function() {
   console.log("Hello from the returned function!");
 };
}
const greeter = getGreeter();
greeter();
```

그래서 자바 스크립트에선 함수가 first class function인데, 이런 원리로 자바의 컬렉션도 똑같이 적용할 수 있다.

```
    public static void main(String[] args) {
        // 컬렉션을 변수에 할당
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        
        // 컬렉션을 함수의 인자로 전달
        printNames(names);
    }
    
    public static void printNames(List<String> names) {
        for (String name : names) {
            System.out.println(name);
        }
    }
```

근데 위 경우엔 문제가 있는데 막 저 names 같은 컬렉션을 외부에서 막 변경할 수 있어서 `단 하나의 컬렉션 필드만 가지는 컬렉션을 추상화한 클래스를 이용해` 새로운 컬렉션을 만들어 반환해주라고 한다.
보면 `List<Cell> cells` 라는 필드를 갖는 Cells 클래스를 구현하고 응답에 새 리스트를 만들어 내려주는 등의 작업을 진행한다. 근데 실무와 관계가 있는 예시가 아니다보니 왜 필요한지 이것도 잘 와닿지 않았다.


> ## 4. 이넘 (이 놈 아님)
.. 그냥 이넘 사용법 알려주셨다.


> ## 5. 다형성 활용

.. 추상화를 묶을 수 있는것들이 status에 따라 여러개의 생성자를 생성해야 하는 상황이면 인터페이스로 묶어서 알아서 주입받을 수 있도록 해라라고 이해했다.


