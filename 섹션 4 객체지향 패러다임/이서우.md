## 프로그래밍 패러다임

프로그래밍 패러다임은 소프트웨어 개발, 문제를 해결하기 위한 스타일, 접근 방식이다.

1. **절차 지향**
    - 순차적인 절차나 명령어로 프로그램을 구성한다.
    - 코드가 명령의 흐름을 따라 실행된다.
    - C
2. **객체 지향**
    - 객체를 중심으로 프로그램을 구성한다.
    - 객체는 속성과 행동으로 이루어져 있다.
    - 객체들 간의 상호작용을 통해 프로그램이 실행된다.
    - Java, C++, Python
3. **함수형**
    - 함수의 조합을 기반으로 프로그램을 구성한다.
    - 입력에 대한 결과는 항상 같으며, 가변 데이터를 멀리 하고 불변성을 강조한다.

## 객체가 제공하는 것

- 절차 지향에서 잘 보이지 않았던 개념을 가시화(객체 그룹을 통해)
- 관심사를 모음으로써 유지보수성 향상
    - 객체 내부에서 객체가 가지는 데이터의 유효성 검증 책임 부여 가능
- 구체적인 구현에 신경쓰지 않고 보다 높은 추상화 레벨에서 도메인 로직 작성 가능

## 객체 지향의 특징 - 캡상추다

추상화를 기반으로 하는 개념들이다.

특징을 잘 활용하면 코드의 재사용성, 유지보수성, 확장성을 높일 수 있다.

- **캡슐화(Encapsulation)**
    - 객체가 가지는 데이터와 데이터를 가공하는 로직을 숨기고, 외부에서는 공개된 인터페이스를 통해서만 상호작용할 수 있도록 하는 것이다.
    - 데이터를 보호하여 무결성을 보장하고, 유지보수를 용이하게 한다.
    - **캡슐화 예시**
        - 클래스 내의 변수는 `private`로 선언하고, 이를 조작하는 메서드는 `public`으로 제공하여 외부에서 직접적으로 데이터를 수정하지 못하게 한다.
- **상속(Inheritance)**
    - 상위 클래스의 속성과 메서드를 물려받고, 기능을 확장하거나 재정의하는 것이다.
    - 클래스 간의 관계를 표현할 수 있고, 중복 코드를 줄일 수 있다.
    - 무분별하게 사용하지 않고 정말 필요한 곳에만 사용하도록 한다.
    - **상속 예시**
        - Animal 클래스를 상속 받은 Cat, Dog 클래스는 Animal의 자원을 사용할 수 있고, 각자의 기능을 추가할 수 있다.
- **추상화(Abstraction)**
    - 본질적인 개념만 정의하고, 세부 구현은 숨긴다. 중요한 속성이나 기능만 노출한다.
    - 인터페이스나 추상 클래스를 통해 무엇을 해야 하는지를 정의한다. 사용자는 구체적인 구현을 몰라도 해당 기능을 사용할 수 있다.
    - 복잡성을 줄이고 중요한 부분만 집중할 수 있게 한다.
    - **추상화 예시**
        - Vehicle이라는 추상 클래스는 drive()라는 추상 메서드를 가지고 있고, 구체적인 Car나 Bike 클래스에서 이를 구체적으로 구현한다.
        - `Shape`라는 추상 클래스가 `draw()`라는 메서드를 정의하면, 이 메서드를 사용하는 사람은 내부적으로 도형이 어떻게 그려지는지 몰라도 `draw()`를 호출하여 도형을 그리게 할 수 있다. 구체적인 도형이 어떤 방식으로 그려지는지는 각 도형 클래스에 맡겨진다.
- **다형성(Polymorphism)**
    - 하나의 메서드나 객체가 여러 형태를 가질 수 있는 것을 의미한다.
    - [메서드] 오버로딩은 동일한 이름의 메서드를 여러 개 정의하는 것이다. 이름은 같지만, 매개변수의 개수나 타입은 다르다.
    - [메서드] 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 자신에 맞게 재정의하여 사용하는 것이다.
    - [객체] 특징을 추출해서 인터페이스화 하고, 실제 구현체가 여러가지 형태로 바뀌며 사용될 수 있도록 하는 것이다.
    - 하나의 인터페이스나 부모 클래스를 통해 여러 다른 구체적인 객체들을 동일한 방식으로 다룰 수 있게 한다.
    - **다형성 예시**
        - `draw()` 메서드가 `Circle`, `Rectangle` 등 다양한 도형 객체에서 각기 다른 방식으로 동작할 수 있다.
        - `Shape`의 서브클래스인 `Circle`, `Rectangle`, `Triangle`이 각각 다르게 `draw()` 메서드를 구현하면, `Shape` 타입으로 `draw()`를 호출할 때 실제 객체에 따라 다른 도형을 그리게 된다.

### 추상화와 다형성

추상화와 다형성의 개념은 혼동될 수 있다. 두 개념은 밀접하게 관련이 있지만, 차이점이 있다.

**특징을 추출해서 인터페이스화 하고, 실제 구현체가 여러 가지 형태로 바뀌며 사용될 수 있다**는 설명은 **두 개념이 결합**된 경우다.

**추상화**는 객체들이 제공할 기능을 정의하는 것이고, **다형성**은 실제 객체가 해당 기능을 어떻게 다르게 구현하고 동작할 수 있는지를 말하는 것이다.

특징을 추출해서 인터페이스화를 하는 것은 **추상화**를 하는 것이고, 실제 구현체가 여러 가지 형태로 바뀌며 사용되도록 하는 것은 **다형성**을 의미하는 것이다.

이 두 개념은 서로 보완적인 역할을 하며, 함께 사용될 때 코드의 **재사용성**과 **유연성**을 높여준다.

**추상화**는 **공통된 기능**을 정의하고, 다양한 객체들이 그 기능을 활용할 수 있도록 한다. 이를 통해 **코드의 재사용성**이 증가합니다.

**다형성**은 **하나의 인터페이스나 부모 클래스를 통해 여러 가지 형태의 객체**를 동일한 방식으로 처리할 수 있게 해준다. 새로운 객체를 쉽게 확장할 수 있고, 다양한 객체를 일관되게 다룰 수 있어 **확장성**과 **유연성**이 향상된다.

다시 정리하자면 다음과 같다.

- **추상화**는 공통된 특징을 뽑아내어 인터페이스나 추상 클래스로 정의하는 것
- **다형성**은 그 인터페이스를 구현하는 다양한 객체들이 **각기 다른 방식**으로 동작할 수 있게 하는 것

## 관심사의 분리

관심사에 따라서 객체를 만들어낼 수 있다. 관심사에 따라 기능과 책임을 나누고, 나눈 것들의 조합으로 프로그램이 수행되도록 하는 것이다. (객체 지향에서만 적용되는 개념은 아니다.)

관심사를 분리한다는 것은 일련의 작업, 개념들을 묶어서 이름, 역할을 부여하는 것이다. 이 또한 추상화 과정의 일면인 것이다.

관심사를 분리하여 객체의 책임을 나누게 되면서 객체 간 협력이 필요해질 수 있다.

### 높은 응집도, 낮은 결합도

- **응집도**
    - 클래스나 모듈 내 요소들이 긴밀하게 연관된 정도
    - 관심사를 모으는 것은 응집도를 높이는 것
- **결합도**
    - 여러 객체가 협력하는 상황에서 하나의 객체가 변경될 때 다른 객체가 영향 받는 정도
    - 객체 간 의존성을 최소화시키는 것이 결합도를 낮추는 것

### 관심사를 모으는 것의 장점

유지보수가 원활해진다.

A라는 관심사를 가진 객체, 모듈, 시스템 등을 모아서 관리하면 A에 대한 것은 해당 항목에 가서 유지보수를 하면 되기 때문이다.

만약 A에 대한 것이 프로그램의 이곳저곳에 관리되지 않은 채로 퍼져있다면 모든 부분을 찾아서 관리해야 한다.

### 객체를 관심사에 따라 응집도 있게 설계하는 방법(객체 생성 시 주의할 점)

1. **관심사를 1개만 갖도록 책임을 정의하기**
    - 요구사항이 변경되면 책임도 변경될 수 있음
2. **객체의 속성에 대한 유효성 검증은 해당 객체가 책임질 수 있도록 하기**
    - 생성자, 정적 팩토리 메서드를 통해 유효성 검증
3. **Setter 사용 자제하기**
    - 사이드 이펙트를 최소화할 수 있도록 가능한 불변 객체로 사용
    - 외부에서 주입된 데이터로 변경이 필요할 경우, 객체가 가지고 있는 데이터들과 새로운 데이터로 새로운 객체를 생성해서 반환
4. **Getter 사용 자제하기**
    - 객체를 객체답게 사용하기 위해, getter로 값을 직접 가져오지 않고, 객체에 메서드를 생성해서 메서드를 통해 메시지를 전달하는 형태로 사용
    - 반드시 필요한 경우에만 추가
5. **필드 수를 최소화하기**
    - 불필요한 데이터가 많을수록 복잡도가 높아지고, 변화에 대응 필요
    - 미리 계산해서 필드로 갖고 있는 것이 성능 상 이점이 있지 않다면, 계산은 메서드를 통해하고 반환해주기

## SOLID 객체지향 설계 원칙

코드의 유지 보수성과 확장성을 높이기 위한 지침이다.

### 단일 책임 원칙 (Single Responsibility Principle, SRP)

- 하나의 클래스는 하나의 책임만 갖도록 한다. = 하나의 클래스의 변경 이유는 단 하나다.
- 객체가 가진 필드, 상수, 공개 메서드 등이 해당 객체의 단일 책임에 의해서만 변경되도록 한다.
- 객체가 가져야 되는 하나의 책임이 무엇인지 계속 질문을 던져야 하고, 인지를 하면서 개발해야 한다.

### 개방 폐쇄 원칙 (Open Closed Principle, OCP)

- 확장에는 열려 있고, 수정에는 닫혀있어야 한다.
- 새로운 코드를 추가해야 할 때, 기존 코드가 과도하게 수정돼야 한다면 OCP가 위배된 것이다.
- 추상화, 다형성, 인터페이스로 OCP를 준수할 수 있다.

**[새로운 요구사항에 유연하게 대응하기]**

요구사항 - 게임 난이도를 변경할 수 있어야 한다.

현재 상태 - 맵 크기 1000, 몬스터의 최대 공격력 20

- 난이도
    - 초급: 맵 크기 1000, 몬스터의 최대 공격력 20
    - 중급: 맵 크기 5000, 몬스터의 최대 공격력 40
    - 고급: 맵 크기 10000, 몬스터의 최대 공격력 80

상수를 사용하지 않고, 입력 값에 따라 게임이 정상 진행될 수 있도록 해야 한다.

게임 레벨이라는 추상화된 인터페이스를 만들고, 각 레벨 클래스에서 구현하도록 한다. 그리고 사용 부분에서 인터페이스 타입을 사용하도록 하고 선택된 난이도에 맞는 구현체를 할당한다.

런타임에 어떤 구현체가 들어올지는 모르지만, 추상화된 스펙을 알고 있기 때문에 구현체에 상관없이 구현해둘 수 있다.


### 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

- 상위 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체할 수 있어야 한다.
- 상위 클래스의 인스턴스가 사용되던 곳에 하위 클래스의 인스턴스를 사용해도 문제가 없어야 한다. 왜냐하면 하위 클래스는 상위 클래스의 기능을 물려받았기 때문이다.
- LSP 위반 시, 예상치 못한 동작이 발생하거나, 이를 방지하기 위한 불필요한 타입 체크(instanceof)가 필요할 수 있다.

### 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

- 인터페이스에 명세된 기능을 구현체에서 일부만 사용한다면, 인터페이스를 더 작게 분리한다.
- ISP 위반 시, 불필요한 의존성으로 인해 결합도가 높아지고, 사용하지 않는 메서드의 시그니처가 변경되어도 인터페이스를 구현하는 모든 클래스에서 수정이 필요하다.


### 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

- 고수준 모듈은 저수준 모듈에 의존하지 않고, 둘 다 추상화된 것에 의존하도록 한다.
- 예를 들어, `OrderService` 클래스가 `EmailNotification` 클래스를 직접 사용하여 이메일을 발송하고 있다면, `OrderService`가 저수준 모듈인 `EmailNotification`에 의존하는 것이다. 대신, `Notification`이라는 추상화된 인터페이스를 두고 `EmailNotification`이 이를 구현하여, `OrderService`가 `Notification` 인터페이스에만 의존하도록 한다.
    - `OrderService`는 `Notification` 인터페이스에만 의존하고, 구체적인 알림 방식(`EmailNotification` 또는 `SMSNotification`)에 대해서는 알지 못한다. 이를 통해 의존성 역전 원칙을 지키게 된다.
    - 알림 방식을 변경하고 싶을 때 `OrderService` 클래스를 수정할 필요가 없고, 알림 방식만 교체하면 된다.
    - `OrderService`가 `Notification` 인터페이스에 의존하므로, 테스트 시 `MockNotification`이라는 테스트용 구현체를 주입하여 독립적인 테스트가 가능하다.
