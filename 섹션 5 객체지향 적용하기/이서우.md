## 상속과 조합


**[상속]**

- 클래스 간 계층 구조 표현
- 중복 제거, 재사용
- 상위 클래스의 자원과 기능을 사용할 수 있게 하면서, 하위 클래스 고유의 자원과 기능도 가질 수 있도록 하는 것
- 상위 클래스 타입이 사용된 곳에 하위 클래스 구현체 사용 가능

**[조합]**

- 한 객체가 자신이 필요한 객체를 가져다가(필드로 선언하는 등) 사용하는 것

### 상속보다는 ‘조합 + 인터페이스’ 사용하기

**[상속의 문제]**

상속은 수정하기 어렵다.

→ 부모와 자식의 결합도가 높다.

→ 부모가 수정되면 모든 자식들에 영향이 간다. (한 객체에 변경이 발생했을 때 다른 객체들이 영향을 많이 받으면 결합도가 높은 것)

**[조합과 인터페이스로 해결]** 

상속이 주는 이점보다는 **중복이 발생하더라도 변경에 대응하기 쉬운 구조로 설계하는 게 유지보수에 용이**할 수 있다. 중복이 발생한다고 해서 중복 해결만을 위해 상속을 적용하는 건 옳지 않다.

- **상위 클래스에 있는 필드를 조합에 사용할 클래스에 선언**
    - 하위 클래스가 상위 클래스의 정보를 알지 않아도 됨
    - 조합에 사용되는 클래스를 자유롭게 변경해도 원래 하위 클래스에 영향을 주지 않게 됨

- **extends Bid → implements Bid**



## Value Object

- 도메인이 가지는 개념을 추상화해서 표현한 객체, 하나의 값처럼 사용
- 불변성, 동등성, 유효성 검증
    - final, setter X
    - 주소가 다른(서로 다른) 인스턴스이지만 필드의 값이 같으면 같은 객체로 취급
        - equals(), hashCode() 재정의
    - 필드에 할당되는 값이 조건을 만족해야 할 경우 객체 생성 시점 및 수정 시점에 검증 수행


## 일급 컬렉션

### 일급 시민

- 변수에 할당 가능
- 파라미터로 전달 가능
- 함수의 결과로 반환 가능

### 일급 함수

함수를 하나의 값처럼 사용 가능

### 일급 컬렉션

- 컬렉션을 클래스로 감싸서 하나의 값처럼 사용 가능
- getter로 컬렉션 반환 시 외부에서의 조작 방지를 위해 새 컬렉션을 생성하여 반환


## Enum

- 상수 집합
- 상수와 관련된 로직 작성
- 코드로 관리하기 때문에 변경 시 재배포 필요, 변경될 여지가 있다면 DB로 관리하는 것을 고려
