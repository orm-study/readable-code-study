# 객체지향 프로그래밍: 추상

## 프로그래밍 패러다임

### 1. 절차지향
- 컴퓨터 처리 구조와 유사하게 처리하는 프로그래밍 방식

### 2. 객체지향
- **객체**를 만들고 객체 간 **협력**을 통해 프로그래밍이 이루어짐

### 3. 함수형
- **순수 함수(Side effects)**가 없는 함수 사용
- 외부 요인 없이 항상 동일한 리턴값을 반환
- 가변 데이터를 지양하며 순수 함수 기반으로 구성

## 객체(Object): 추상화된 데이터 + 코드

- **객체**는 추상화된 [데이터 + 코드]를 의미
- 객체가 여러 개가 되면 객체 간 **협력**과 객체가 담당하는 **추상화**가 중요해짐

### 캡슐화 (Encapsulation)
- 객체가 가진 데이터를 숨기고, 가공하는 로직도 숨긴 채 외부에 일부만 공개
- **추상화**의 하위 개념으로서 데이터와 로직을 보호

### 상속 (Inheritance)
- 재사용성과 확장성을 높이지만, 제한적으로 사용해야 함

### 다형성 (Polymorphism)
- 상위 추상화 레벨에서 요구되는 특징을 인터페이스로 정의하고, 여러 가지 형태로 구현 가능
- 코드의 유연성과 확장성을 높임

### 관심사의 분리 (Separation of Concern)
- 관심사를 분리하여 각각의 작업 혹은 개념에 명확한 역할 부여
- **높은 응집도, 낮은 결합도** 유지
  - 높은 응집도: 하나의 모듈이나 객체가 명확한 책임을 가짐
  - 낮은 결합도: 각 모듈이나 객체가 다른 모듈에 의존하지 않음
- 결합도가 낮을수록, 하나의 변경이 다른 부분에 의도치 않은 영향을 미치지 않음

## 객체 설계하기 (1)

- **메서드를 추상화로 추출**하듯이, 객체도 추상화할 수 있음
- 객체 내부의 데이터와 로직은 **내부 세계**이며, 외부와의 상호작용은 **공개 메서드**를 통해 이루어짐

### 내부 세계와 외부 세계
- **객체 내부**: 비공개 필드(데이터)와 비공개 로직(코드)
- **외부 세계**: 외부와의 소통을 위한 **공개 메서드**만 제공
  - 공개 메서드는 객체의 책임을 드러내는 창구 역할

### 협력
- 객체들이 서로 **협력**하여 시스템 내에서 기능을 수행
- 객체의 책임이 나뉨에 따라 **관심사 분리**가 이루어지고, 각 객체 간 적절한 협력 관계가 필요

### 객체가 제공하는 것
- 절차지향 프로그래밍에서 잘 보이지 않던 개념을 가시화
- 관심사가 집중되므로 유지보수성 증가
- **캡슐화**로 인해 구체적인 구현에 신경 쓰지 않고 추상화된 도메인 로직을 다룰 수 있음

### 새로운 객체를 만들 때 주의사항
- 1개의 명확한 **관심사**와 책임이 정의되었는지 확인
  - 객체를 만들 때 외부 세계와 어떤 소통을 하려는지 고민해야 함
- **유효성 검증**은 생성자와 정적 팩토리 메서드에서 처리 가능
  - 예: 은행 앱에서 입금 시 금액이 0원 이상인지 확인하는 검증 로직
- **Setter** 사용 자제
  - 데이터는 불변성을 유지하는 것이 바람직하며, 변경 시 객체 내부에서 처리
  - 외부 요청에 의해 데이터를 변경해야 한다면 set~~ 대신 update~~ 형식으로 네이밍하는 것이 좋음
- **Getter** 남발 자제
  - 외부에서 데이터를 가져오기보다는, 데이터를 처리하는 기능을 제공하는 메서드를 활용
  - 예: 나이가 19세 이상인지 확인할 때 getAge() 대신 isAdult() 같은 메서드를 만드는 것이 좋음
- **필드의 수는 적을수록 좋음**
  - 불필요한 데이터가 많으면 복잡도가 증가하고, 변화에 대한 대응이 어려워짐
  - 단, 성능상 이점이 있다면 일부 데이터를 필드로 미리 가공할 수도 있음

## 객체 설계하기 (2)

- 개념적으로 **열림/닫힘**과 사용자가 **체크**하는 것은 다름
- 상황에 따라 **Cell**이라는 객체를 만들어, 보드는 그저 Cell을 관리하는 구조로 리팩토링 가능
- 도메인 지식은 **만드는 것**이 아니라 **발견하는 것**
- 새로운 도메인 발견 시 전체적인 흐름을 보고 객체 상태를 변화시키는 방식으로 설계할 필요가 있음

## SOLID 원칙

### 1. SRP (Single Responsibility Principle)
- 객체는 **하나의 책임**만 가져야 한다.
- 예: 객체는 하나의 기능만 수행하고, 해당 기능의 변경에 대해서만 영향을 받아야 함

### 2. OCP (Open/Closed Principle)
- 객체는 **확장에는 열려 있고**, **수정에는 닫혀 있어야 한다**.
- 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있어야 함

### 3. LSP (Liskov Substitution Principle)
- **자식 클래스**는 언제나 **부모 클래스를 대체**할 수 있어야 한다.
- 하위 타입은 상위 타입의 행위를 대체할 수 있어야 함

### 4. ISP (Interface Segregation Principle)
- **클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.**
- 인터페이스는 클라이언트에 맞춰 분리되어야 함

### 5. DIP (Dependency Inversion Principle)
- 고수준 모듈은 저수준 모듈에 의존하지 않고, **추상화**에 의존해야 한다.
- 추상화된 인터페이스에 의존하여 구현의 변화에 유연하게 대처 가능

## 1. 추상의 관점으로 바라보는 객체 지향

### 1.1. **절차 지향 (Procedural Programming)**

- 순차적인 절차나 명령어로 프로그램을 구성
- 데이터와 함수를 분리해서 작성
- C

### 1.2. **객체 지향 (Object-Oriented Programming, OOP)**

- 객체를 중심으로 프로그램을 구성
- **객체의 협력과 책임**이 중점
- **캡슐화, 상속, 추상화, 다형성** 특징을 기반으로 프로그래밍

### 1.3. **함수형 프로그래밍 (Functional Programming)**

- 순수 함수 기반으로 변하지 않는 값을 사용하는 패러다임
- 가변 상태를 피하고 불변성을 강조

## 객체 설계하기

### 2.1. 객체로 추상화 하기
- **비공개 필드(데이터)**와 **비공개 로직(코드)**를 가진다.
- **공개 메서드**를 통해 외부와 소통하며 책임을 나누고 협력한다.

### 2.2. 객체가 제공하는 것
- **유효성 검증** 같은 책임을 내부에서 처리하며, 구체적인 구현에 신경 쓰지 않아도 된다.

### 2.3. 새로운 객체 설계 시 주의할 점
- 1개의 **관심사**로 명확하게 책임이 정의되었는지 확인한다.
- **Setter**, **Getter** 사용을 자제한다.

## 3. SOLID 원칙

### 3.1. SRP: 단일 책임 원칙
- 객체는 하나의 책임만 가져야 한다.

### 3.2. OCP: 개방 폐쇄 원칙
- 확장에는 열려있고, 수정에는 닫혀있어야 한다.

### 3.3. LSP: 리스코프 치환 원칙
- 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.

### 3.4. ISP: 인터페이스 분리 원칙
- 클라이언트는 사용하지 않는 인터페이스에 의존해서는 안된다.

### 3.5. DIP: 의존 역전 원칙
- 상위 수준 모듈은 하위 수준 모듈에 의존하지 말아야 한다. 
