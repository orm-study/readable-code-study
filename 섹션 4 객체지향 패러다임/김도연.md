# 4. 객체 지향 패러다임

# 추상의 관점으로 바라보는 객체지향

## 객체(Object)

추상화된 [데이터 + 코드]

- 데이터와 데이터를 조작 혹은 가공하는 코드가 같이 묶인 녀석

## 협력과 책임

객체 간의 협력과 객체가 담당하는 책임의 관점으로 추상화를 접목시켜 이해하는 것이 중요하다.

## 캡추상다

캡슐화: 객체가 가지고 있는 데이터를 숨기고 그 데이터를 가공하는 로직도 숨기고 외부에 일부만 드러내는 것 (추상화의 하위개념) 

추상화

상속

다형성: 상위 추상화 레벨에서 요구되는 특징만을 뽑아내서 인터페이스화 한 뒤 실제 구현체들이 여러가지 형태로 바뀌어서 사용될 수 있는 것

## 관심사의 분리

특정한 관심사에 따라서 객체를 만들어낼 수 있다.(기능과 책임을 분리)

→ 유지보수에 유용함

- 높은 응집도, 낮은 결합도(하나가 바뀌었을 때 다른 하나가 영향을 받는 정도)

# 객체 설계하기(1)

- 비공개 필드(데이터), 비공개 로직(코드)
- 공개 메서드의 선언부를 통해 외부 세계와 소통
    - 각 메서드의 기능은 객체의 책임을 드러내는 창구
- 객체의 책임이 나뉨에 따라 객체 간 협력이 발생

## 객체가 제공하는 것

- 관심사가 한 군데로 모이기 때문에, 유지보수성 증가
    - ex. 객체 내부에서 객체가 가진 데이터의 유효성 검증 책임을 가질 수 있다.
- 여러 객체를 사용하는 입장에서는, 구체적인 구현에 신경 쓰지 않고 보다 높은 추상화 레벨에서 도메인 로직을 다룰 수 있다. (캡슐화 처리가 되어있어 이미 추상화되어 있는 기능들을 사용)

## 새로운 객체를 만들 때 주의할 점

- 1개의 관심사로 명확하게 책임이 정의되었는지 확인하기

- setter 사용 자제
    - 데이터는 불변이 최고다. 변하는 데이터더라도 객체가 핸들링할 수 있어야 한다.
        - 객체 내부에서 외부 세계의 개입 없이 자체적인 변경/가공으로 처리할 수 있는지를 확인
    - 만약 외부에서 가지고 있는 데이터로 데이터 변경 요청을 해야하는 경우, ‘set~’이라는 단순한 이름보다는 ‘update~’와 같이 의도를 드러내는 네이밍을 고려하자.

- getter도 처음에는 사용 자제
    - 객체를 만들고, 반드시 필요한 순간에 만들자.
    - 객체에 메시지를 보내라 (객체로서 존중해주고, 대우해주자)
        - getter를 쓰고 싶은데, 혹시 객체에 물어볼 수 있지 않을까?
    
    ```java
    Person person = new Person();
    
    //(1)
    if(person.get지갑().get신분증().findAge() >= 19){
    	pass();
    }
    
    //(2)
    if(person.isAgeGreaterThanOrEqualTo(19)){
    	pass();
    }
    ```
    

- 필드의 수는 적을수록 적다.
    - 불필요한 데이터가 많을수록 복잡도가 높아지고 대응할 변화가 많아진다.
    - 필드 A를 가지로 계산할 수 있는 A’ 필드가 있다면, 메서드 기능으로 제공
    - 단, 미리 가공하는 것이 성능 상 이점이 있다면, 필드로 가지고 있는 것이 좋을 수도 있다.

- 캡슐화되어있는 데이터를 바깥에서 알고 있다고 생각하지 말자.

## 점진적 리팩토링

```java
private static final String[][] BOARD = new String[BOARD_ROW_SIZE][BOARD_COL_SIZE];
private static final Cell[][] BOARD2 = new Cell[BOARD_ROW_SIZE][BOARD_COL_SIZE];
```

BOARD2를 생성해놓고 기존에 BOARD를 사용하던 로직을 모두 BOARD2를 사용하도록 바꾼 뒤, BOARD를 사용하는 곳이 더 이상 존재하지 않을 때 BOARD를 삭제한 뒤 BOARD2를 BOARD로 바꾼다.

### NPE 방지

```java
return this.sign.equals(CLOSED_CELL_SIGN); //NPE 발생 가능성

return CLOSED_CELL_SIGN.equals(this.sign); //NPE 방지
//상수로부터 equals를 호출하자.
```

객체를 갈아끼우는 곳이 아니라, 사용자 행위에 따라 Cell의 상태를 변화시키는 방향으로 가야 한다.

새로운 도메인 지식을 발견.. 과감하게 사고를 전환한다.

# SOLID

# SRP : Single Responsibility Principle

단일 책임 원칙

main 이라는 자바의 진입점 함수는 게임 프로그램을 실행하는 역할만 딱 하게 하고 지뢰찾기 도메인, 게임 자체를 실행하는 클래스를 별도로 두면 어떨까

→ main 함수를 가지고 있는 class는 프로그램의 진입점만 가지고 지뢰찾기 게임을 실행할 책임

게임이 여러가지면 다른 게임도 실행해볼 수 있겠다.

게임 실행에 대한 책임과 지뢰찾기 도메인 자체, 지뢰찾기 게임을 담당하는 역할을 분리

게임이 진행되는 핵심 로직과 입출력에 대한 로직을 분리

# OCP : Open-Closed Principle

개방-폐쇄 원칙

- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
    - 기존 코드의 변경 없이, 시스템의 기능을 확장할 수 있어야 한다.
- 추상화와 다형성을 활용해서 OCP를 지킬 수 있다.

### 새로운 요구사항

- 게임의 난이도를 변경할 수 있어야 한다.
    - 난이도와 관련된 것(가로, 세로, 지뢰)들이 상수로 빠져있어 OCP를 잘 지키지 못하고 있다.

방법 2가지

1. 난이도와 관련된 것을 interface로 분리
2. 난이도와 관련된 것을 enum으로 분리

지뢰게임을 실행하는 객체는 GameLevel interface의 구현체를 받아와서 실행한다.

# LSP : Liskov Substitution Principle

리스코프 치환 원칙

- 상속 구조에서, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환할 수 있어야 한다.
    - 자식 클래스는 부모 클래스의 책임을 준수하며, 부모 클래스의 행동을 변경하지 않아야 한다.
        - 부모 클래스의 책임들을 그대로 가져가면서 추가적으로 뭔가를 더 해야한다.
- LSP를 위반하면, 상속 클래스를 사용할 때 오동작, 예상 밖의 예외가 발생하거나, 이를 방지하기 위한 불필요한 타입 체크가 동반될 수 있다.

부모가 일하는 곳에 자식3이 갔다가 올바른 방향으로 동작하지 않거나, 예상치 못한 예외가 발생하거나, 이를 방지하기 위해 자식3의 타입을 체크하는 분기가 발생할 수 있다.

# ISP

인터페이스 분리 원칙

인터페이스를 상속한 클래스를 구현하면서 필요없는 기능이 있다면? 인터페이스를 분리해야한다는 신호이다.

인터페이스를 사용할 때마다 인터페이스가 특정 하나의 기능, 책임에 대해서만 구성되어있는 게 맞는지 질문을 던지면서 리팩토링을 하자.

# DIP: Dependency Inversion Principle

의존성 역전 원칙

- 상위 수준의 모듈을 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
    - 추상화 레벨이 높은 쪽의 모듈이 구체에 가까운 모듈에 직접적으로 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
- 의존성의 순방향: 고수준 모듈이 저수준 모듈을 참조하는 것
- 의존성의 역방향: 고수준, 저수준 모듈이 모두 추상화에 의존하는 것

의존성의 순방향이 자연스러운 것이지만, 저수준 모듈이라는 것은 자주 바뀔 수 있음.(구체 쪽에 가깝기 때문에)

기능을 추상화해서 고수준 모듈은 그 추상화된 스펙만 참조하도록 하는 것이 의존성의 역방향이다.

→ 고수준 모듈은 구체는 모르면서 추상화된 스펙만 참조. 

→ 저수준 모듈은 인터페이스의 구현체이므로 언제든지 갈아끼워질 수 있음.

저수준 모듈이 변경되어도 고수준 모듈에는 영향이 가지 않는 설계이다.

## 의존성

하나의 모듈이 다른 하나의 모듈을 알고 있거나 직접적으로 생성하거나 사용하는 모든 것들

### DI (Dependency Injection) - “3”

의존성 주입. 필요한 의존성을 외부에서 주입받음

### IoC (Inversion of Control)

제어의 역전. 프로그램의 흐름을 개발자가 아닌 프레임워크가 담당하도록 하는 것.

내 코드는 프레임워크의 일부. 프로그램 제어의 주도권이 프레임워크 쪽으로 간다.
